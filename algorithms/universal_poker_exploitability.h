#ifndef DEEP_CFR_UNIVERSAL_POKER_EXPLOITABILITY_
#define DEEP_CFR_UNIVERSAL_POKER_EXPLOITABILITY_

#include <array>
#include <memory>
#include <string>
#include <utility>
#include <vector>

#include "Eigen/Core"
#include "absl/algorithm/container.h"
#include "open_spiel/algorithms/public_tree.h"
#include "open_spiel/game_parameters.h"
#include "open_spiel/games/universal_poker.h"
#include "open_spiel/games/universal_poker/acpc_cpp/acpc_game.h"
#include "open_spiel/games/universal_poker/logic/card_set.h"
#include "open_spiel/policy.h"
#include "open_spiel/spiel.h"
#include "open_spiel/utils/barrier.h"
#include "open_spiel/utils/thread_pool.h"
#include "vpnet.h"

namespace open_spiel {
namespace universal_poker {

class UniversalPokerExploitability {
  // Only for universal poker with 2 players, and 2 rounds.
 public:
  UniversalPokerExploitability(const Game &game, const Policy &policy,
                               algorithms::CFRNetModel *net = nullptr,
                               int num_threads = 1);

  ~UniversalPokerExploitability() = default;

  double operator()() { return (br_run(0) + br_run(1)) / 2; }

  double br_run(Player player);

 private:
  Eigen::ArrayXd Evaluate(Player player, const UniversalPokerState *state,
                          const Eigen::ArrayXd &p, const Eigen::ArrayXd &q,
                          const logic::CardSet &outcome, int index);

  Eigen::ArrayXd _dist_br_chance(Player player, algorithms::PublicNode *node,
                                 const Eigen::ArrayXd &valid_p,
                                 const Eigen::ArrayXd &p_s_ni,
                                 const logic::CardSet &outcome,
                                 const logic::CardSet &cards, int index);

  Eigen::ArrayXd _array_reduce(const Eigen::ArrayXd &arr, int index);

  Eigen::ArrayXd _br_recursive(Player palyer, algorithms::PublicNode *node,
                               const Eigen::ArrayXd &valid_p,
                               const Eigen::ArrayXd &p_s_ni,
                               const logic::CardSet &outcome, int index);

 private:
  int step_;
  const UniversalPokerGame *game_;
  const Policy *policy_;
  algorithms::CFRNetModel *net_;
  std::vector<algorithms::PublicTree> trees_;
  const acpc_cpp::ACPCGame *acpc_game_;
  logic::CardSet deck_;
  std::vector<logic::CardSet> player_outcomes_;
  std::vector<std::vector<uint8_t>> player_outcome_arrays_;
  std::vector<logic::CardSet> board_outcomes_;
  std::vector<std::vector<uint8_t>> board_outcome_arrays_;
  Eigen::ArrayXXd valid_matrix_;
  std::vector<Eigen::ArrayXXd> compared_cache_;
  int num_outcomes_;
  int num_hole_cards_;
  int num_board_cards_;
  double root_proba_;
  double board_proba_;
  logic::CardSet default_cards_;

  int num_threads_;
  std::unique_ptr<ThreadPool> pool_;
  std::vector<Eigen::ArrayXd> reduce_arrays_;
  Eigen::ArrayXd reduced_value_;
  Barrier barrier_;

  int over_ratio_;
};

}  // namespace universal_poker
}  // namespace open_spiel

#endif  // DEEP_CFR_UNIVERSAL_POKER_EXPLOITABILITY_