#include "universal_poker_exploitability.h"

#include <algorithm>
#include <array>
#include <cstdint>
#include <queue>
#include <utility>
#include <vector>

#include "absl/algorithm/container.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/strings/str_join.h"
#include "open_spiel/game_parameters.h"
#include "open_spiel/games/universal_poker/logic/card_set.h"
#include "open_spiel/spiel.h"
#include "open_spiel/spiel_utils.h"
#include "open_spiel/utils/barrier.h"

namespace open_spiel {
namespace universal_poker {
using namespace open_spiel::algorithms;
namespace {
long long C(int n, int r) {
  if (r > n - r) r = n - r;
  long long ans = 1;
  int i;

  for (i = 1; i <= r; i++) {
    ans *= n - r + i;
    ans /= i;
  }
  return ans;
}
}  // namespace

UniversalPokerExploitability::UniversalPokerExploitability(const Game &game,
                                                           const Policy &policy,
                                                           CFRNetModel *net,
                                                           int num_threads)
    : game_(static_cast<const UniversalPokerGame *>(&game)),
      policy_(&policy),
      net_(net),
      num_threads_(num_threads),
      pool_(new ThreadPool(num_threads)),
      barrier_(num_threads),
      reduce_arrays_(num_threads),
      over_ratio_(1),
      acpc_game_(game_->GetACPCGame()),
      deck_(/*num_suits=*/acpc_game_->NumSuitsDeck(),
            /*num_ranks=*/acpc_game_->NumRanksDeck()) {
  num_hole_cards_ = acpc_game_->GetNbHoleCardsRequired();
  num_board_cards_ = acpc_game_->GetTotalNbBoardCards();
  player_outcomes_ = deck_.SampleCards(num_hole_cards_);
  player_outcome_arrays_.resize(player_outcomes_.size());
  absl::c_transform(player_outcomes_, player_outcome_arrays_.begin(),
                    [](const logic::CardSet &cs) { return cs.ToCardArray(); });
  if (num_board_cards_) {
    board_outcomes_ = deck_.SampleCards(num_board_cards_);
  }
  board_outcome_arrays_.resize(board_outcomes_.size());
  absl::c_transform(board_outcomes_, board_outcome_arrays_.begin(),
                    [](const logic::CardSet &cs) { return cs.ToCardArray(); });

  num_outcomes_ = player_outcomes_.size() * player_outcomes_.size();
  int num_cards = acpc_game_->NumSuitsDeck() * acpc_game_->NumRanksDeck();
  root_proba_ = 1.0 / (C(num_cards, num_hole_cards_) *
                       C(num_cards - num_hole_cards_, num_hole_cards_));
  board_proba_ = 1.0 / C(num_cards - 2 * num_hole_cards_, num_board_cards_);
  valid_matrix_ =
      Eigen::ArrayXXd(player_outcomes_.size(), player_outcomes_.size());
  for (int i = 0; i < player_outcomes_.size(); ++i) {
    for (int j = 0; j < player_outcomes_.size(); ++j) {
      logic::CardSet cs = player_outcomes_[i];
      cs.Combine(player_outcomes_[j]);
      valid_matrix_(i, j) = (cs.NumCards() == 2 * num_hole_cards_);
    }
  }
  int num_trees = (num_threads > 1) ? (over_ratio_ * num_threads) : 1;
  for (int i = 0; i < num_trees; ++i) {
    trees_.emplace_back(game_->NewInitialState());
  }
  compared_cache_.resize(num_trees);
}

double UniversalPokerExploitability::br_run(Player player) {
  step_ = 0;
  Eigen::ArrayXd valid_p = Eigen::ArrayXd::Ones(player_outcomes_.size());
  Eigen::ArrayXd p_s_ni = Eigen::ArrayXd::Ones(player_outcomes_.size());
  std::future<Eigen::ArrayXd> ret;
  for (int t = 0; t != num_threads_; ++t) {
    ret = pool_->enqueue(&UniversalPokerExploitability::_br_recursive, this,
                         player, trees_[t].Root(), valid_p, p_s_ni,
                         default_cards_, t);
  }
  return ret.get().sum();
}

Eigen::ArrayXd UniversalPokerExploitability::Evaluate(
    Player player, const UniversalPokerState *state, const Eigen::ArrayXd &p,
    const Eigen::ArrayXd &q, const logic::CardSet &outcome, int index) {
  // values = p * (value_matrx * valid_matrix_) \dot q.
  // For two players.
  double player_spent = state->acpc_state_.CurrentSpent(player);
  double other_spent =
      state->acpc_state_.TotalSpent() - state->acpc_state_.CurrentSpent(player);
  if (state->acpc_state_.NumFolded() >= state->acpc_game_->GetNbPlayers() - 1) {
    // Some one folded here.
    double scale_value = 0;
    if (state->acpc_state_.PlayerFolded(player)) {
      scale_value = -player_spent;
    } else {
      scale_value = other_spent;
    }
    return scale_value * root_proba_ * p *
           (valid_matrix_.matrix() * q.matrix()).array();
  } else {
    // Show down here. For two player limited game, all players should spent the
    // same money.
    SPIEL_CHECK_EQ(player_spent, other_spent);
    Eigen::ArrayXi ranks(player_outcomes_.size());
    for (int i = 0; i < player_outcomes_.size(); ++i) {
      logic::CardSet cs = player_outcomes_[i];
      cs.Combine(outcome);
      if (cs.NumCards() != (num_hole_cards_ + num_board_cards_)) {
        ranks(i) = -1;
      } else {
        ranks(i) = cs.RankCards();
      }
    }
    if (!compared_cache_[index].size()) {
      compared_cache_[index] =
          Eigen::ArrayXXd(player_outcomes_.size(), player_outcomes_.size());
      Eigen::ArrayXXd &compared = compared_cache_[index];
      for (int i = 0; i < player_outcomes_.size(); ++i) {
        for (int j = i; j < player_outcomes_.size(); ++j) {
          compared(i, j) =
              (ranks[i] > ranks[j]) ? 1 : ((ranks[i] < ranks[j]) ? -1 : 0);
          compared(j, i) = -compared(i, j);
        }
      }
      compared_cache_[index] = compared * valid_matrix_;
    }
    return other_spent * root_proba_ * p *
           (compared_cache_[index].matrix() * q.matrix()).array();
  }
}

Eigen::ArrayXd UniversalPokerExploitability::_dist_br_chance(
    Player player, algorithms::PublicNode *node, const Eigen::ArrayXd &valid_p,
    const Eigen::ArrayXd &p_s_ni, const logic::CardSet &outcome,
    const logic::CardSet &cards, int index) {
  logic::CardSet new_outcome = outcome;
  new_outcome.Combine(cards);
  algorithms::PublicNode *new_node = node->GetChild(node->GetChildActions()[0]);
  int check_num = num_hole_cards_ + new_outcome.NumCards();
  Eigen::ArrayXd new_valid_p = valid_p;
  Eigen::ArrayXd new_p_s_ni = p_s_ni;
  for (int inf_id = 0; inf_id != player_outcomes_.size(); ++inf_id) {
    logic::CardSet check_cards = new_outcome;
    check_cards.Combine(player_outcomes_[inf_id]);
    if (check_cards.NumCards() != check_num) {
      new_valid_p(inf_id) = 0;
      new_p_s_ni(inf_id) = 0;
    }
  }
  return _br_recursive(player, new_node, new_valid_p, new_p_s_ni, new_outcome,
                       index);
}

Eigen::ArrayXd UniversalPokerExploitability::_array_reduce(
    const Eigen::ArrayXd &arr, int index) {
  reduce_arrays_[index] = arr;
  if (barrier_.Block([&]() {
        reduced_value_ = Eigen::ArrayXd::Zero(player_outcomes_.size());
        for (int i = 0; i != num_threads_; ++i) {
          reduced_value_ += reduce_arrays_[i];
        }
      })) {
  }
  return reduced_value_;
}

Eigen::ArrayXd UniversalPokerExploitability::_br_recursive(
    Player player, algorithms::PublicNode *node, const Eigen::ArrayXd &valid_p,
    const Eigen::ArrayXd &p_s_ni, const logic::CardSet &outcome, int index) {
  UniversalPokerState *state =
      static_cast<UniversalPokerState *>(node->GetState());
  if (state->IsTerminal()) {
    return Evaluate(player, state, valid_p, p_s_ni, outcome, index);
  }
  if (state->IsChanceNode()) {
    Eigen::ArrayXd values = Eigen::ArrayXd::Zero(player_outcomes_.size());
    std::queue<std::future<Eigen::ArrayXd>> results;
    for (int i = 0; i < board_outcomes_.size(); ++i) {
      if (i % num_threads_ != index) {
        continue;
      }
      auto &cards = board_outcomes_[i];
      compared_cache_[index] = Eigen::ArrayXXd(0, 0);
      values +=
          _dist_br_chance(player, node, valid_p, p_s_ni, outcome, cards, index);
    }
    values = _array_reduce(values, index);
    values *= board_proba_;
    step_++;
    return values;
  }
  Player current_player = state->CurrentPlayer();
  std::vector<Action> legal_actions = state->LegalActions();
  // dim 0: information index, dim 1: action index.
  Eigen::ArrayXXd s_sigma_o_a(player_outcomes_.size(), legal_actions.size());
  if (current_player != player) {
    std::vector<CFRNetModel::InferenceInputs> net_inputs;
    for (int inf_id = 0; inf_id != player_outcomes_.size(); ++inf_id) {
      if (valid_p(inf_id)) {
        // NOTE: We have to modify state, in order to get the information set.
        // So the _br_recursive must be not thread-saft.
        state->SetHoleCards(current_player, player_outcome_arrays_[inf_id]);
        state->SetBoardCards(outcome);
        if (net_ != nullptr) {
          net_inputs.push_back(CFRNetModel::InferenceInputs{
              node->GetState()->InformationStateString(), state->LegalActions(),
              node->GetState()->InformationStateTensor()});
        } else {
          auto inf_policy = policy_->GetStatePolicy(*state);
          for (int axid = 0; axid != legal_actions.size(); ++axid) {
            s_sigma_o_a(inf_id, axid) = inf_policy[axid].second;
          }
        }
      } else {
        s_sigma_o_a.row(inf_id) = 0;
      }
    }
    // NOTE: special inference when using cfrnet model.
    if (net_inputs.size() > 0) {
      std::vector<CFRNetModel::InferenceOutputs> net_outputs =
          net_->InfPolicy(current_player, net_inputs);
      int output_index = 0;
      for (int inf_id = 0; inf_id != player_outcomes_.size(); ++inf_id) {
        if (valid_p(inf_id)) {
          for (int axid = 0; axid != legal_actions.size(); ++axid) {
            s_sigma_o_a(inf_id, axid) = net_outputs[output_index].value[axid];
          }
          ++output_index;
        }
      }
    }
  }
  Eigen::ArrayXd values = Eigen::ArrayXd::Zero(player_outcomes_.size());
  Eigen::ArrayXXd m(player_outcomes_.size(), legal_actions.size());
  for (int axid = 0; axid != legal_actions.size(); ++axid) {
    if (current_player == player) {
      algorithms::PublicNode *next_node = node->GetChild(legal_actions[axid]);
      m.col(axid) =
          _br_recursive(player, next_node, valid_p, p_s_ni, outcome, index);
    } else {
      algorithms::PublicNode *next_node = node->GetChild(legal_actions[axid]);
      Eigen::ArrayXd new_p_s_ni = p_s_ni * s_sigma_o_a.col(axid);
      values +=
          _br_recursive(player, next_node, valid_p, new_p_s_ni, outcome, index);
    }
  }
  if (state->CurrentPlayer() == player) {
    values = m.rowwise().maxCoeff();
  }
  return values;
}  // namespace universal_poker
}  // namespace universal_poker
}  // namespace open_spiel