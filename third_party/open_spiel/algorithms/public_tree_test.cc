// Copyright 2019 DeepMind Technologies Ltd. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "open_spiel/algorithms/public_tree.h"

#include <cmath>
#include <functional>
#include <iostream>
#include <unordered_set>

#include "open_spiel/algorithms/minimax.h"
#include "open_spiel/game_parameters.h"
#include "open_spiel/games/goofspiel.h"
#include "open_spiel/games/kuhn_poker.h"
#include "open_spiel/games/leduc_poker.h"
#include "open_spiel/games/liars_dice.h"
#include "open_spiel/games/tic_tac_toe.h"
#include "open_spiel/spiel.h"
#include "open_spiel/spiel_utils.h"

namespace open_spiel {
namespace algorithms {
namespace {

void TestGameTree() {
  std::vector<std::string> game_names = {"leduc_poker", "kuhn_poker",
                                         "liars_dice"};
  std::unordered_map<std::string, int> num_histories = {
      // Not sure if these are correct. Chosen to make test pass. They seem to
      // have the right order of magnitude.
      {"kuhn_poker", 11},
      {"leduc_poker", 92},
      {"liars_dice", 8193}};

  for (const auto& game_name : game_names) {
    std::shared_ptr<const Game> game = LoadGame(game_name);
    PublicTree tree(game->NewInitialState());
    if (tree.NumHistories() != num_histories[game_name]) {
      // TODO(b/126764761): Replace calls to SpielFatalError with more
      // appropriate test macros once they support logging.
      SpielFatalError(absl::StrCat(
          "In the game ", game_name,
          ", tree has wrong number of nodes: ", tree.NumHistories(), "but ",
          num_histories[game_name], "nodes were expected."));
    }

    // Check that the root is not null.
    if (tree.Root() == nullptr) {
      SpielFatalError("Root of PublicTree is null for game: " + game_name);
    }
    for (const std::string& history : tree.GetHistories()) {
      PublicNode* node = tree.GetByHistory(history);
      std::cout << history << std::endl;
      if (node == nullptr) {
        SpielFatalError(absl::StrCat("node is null for history: ", history,
                                     " in game: ", game_name));
      }
      if (node->GetState() == nullptr) {
        SpielFatalError(absl::StrCat("state is null for history: ", history,
                                     " in game: ", game_name));
      }
      if (node->GetState()->ToString() != node->GetHistory()) {
        SpielFatalError(
            "history generated by state does not match history"
            " stored in PublicNode.");
      }
      if (history != node->GetHistory()) {
        SpielFatalError(
            "history key does not match history stored in "
            "PublicNode.");
      }
      if (node->GetType() != StateType::kTerminal &&
          node->GetType() != StateType::kChance) {
        std::vector<Action> legal_actions = node->GetState()->LegalActions();
        std::vector<Action> child_actions = node->GetChildActions();
        if (legal_actions.size() != child_actions.size()) {
          SpielFatalError(absl::StrCat(
              "For state ", history, ", child actions has a different size (",
              child_actions.size(), ") than legal actions (",
              legal_actions.size(), ")."));
        }
        for (int i = 0; i < legal_actions.size(); ++i) {
          if (legal_actions[i] != child_actions[i]) {
            SpielFatalError(absl::StrCat(
                "legal_actions[i] != child_actions[i]: ", legal_actions[i],
                " != ", child_actions[i]));
          }
        }
      }

      if (node->GetType() != StateType::kTerminal &&
          node->GetType() != StateType::kChance &&
          node->NumChildren() != node->GetState()->LegalActions().size()) {
        SpielFatalError(
            absl::StrCat("number of child nodes does not match number of legal"
                         " actions in history: ",
                         history, " in game: ", game_name));
      }
    }
  }
}

}  // namespace
}  // namespace algorithms
}  // namespace open_spiel

int main(int argc, char** argv) { open_spiel::algorithms::TestGameTree(); }
